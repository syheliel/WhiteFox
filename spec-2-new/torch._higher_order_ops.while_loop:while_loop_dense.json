{
    "summary": "\nThe while_loop_dense function implements the core while loop operation in PyTorch's higher-order operators. The vulnerable lines perform critical input validation:\n1. Checks that carried_inputs is a tuple/list to ensure proper iteration state handling\n2. Validates the condition predicate is either:\n   - A boolean scalar tensor (size [] and dtype bool)\n   - A Python boolean value\nThese checks are essential for:\n- Maintaining correct loop semantics\n- Preventing type-related runtime errors\n- Ensuring proper tensor metadata handling\n- Supporting both tensor and non-tensor loop conditions\n```\n\n```python\nimport torch\n\ndef cond_fn(iter, x):\n    return iter < 5\n\ndef body_fn(iter, x):\n    return iter + 1, x * 2\n\n# Example triggering both validation checks\nresult = torch.ops.higher_order.while_loop(\n    cond_fn,\n    body_fn,\n    carried_inputs=(torch.tensor(0), torch.randn(3))\n)\n```\n\n```yaml\n- torch.ops.higher_order.while_loop\n- torch.Tensor.size\n- torch.Tensor.dtype\n- torch.Size\n",
    "python_code": "\nimport torch\n\ndef cond_fn(iter, x):\n    return iter < 5\n\ndef body_fn(iter, x):\n    return iter + 1, x * 2\n\n# Example triggering both validation checks\nresult = torch.ops.higher_order.while_loop(\n    cond_fn,\n    body_fn,\n    carried_inputs=(torch.tensor(0), torch.randn(3))\n)\n```\n\n```yaml\n- torch.ops.higher_order.while_loop\n- torch.Tensor.size\n- torch.Tensor.dtype\n- torch.Size\n",
    "api": [
        "torch.ops.higher_order.while_loop",
        "torch.Tensor.size",
        "torch.Tensor.dtype",
        "torch.Size"
    ]
}