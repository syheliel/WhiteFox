{
    "summary": "\nThe EQUALS_MATCH function in GuardBuilder handles equality comparison guards for various Python and PyTorch types. Key aspects include:\n1. Special handling for NaN values (both float and complex)\n2. Type validation for common constant types\n3. Comparison logic for mutable vs immutable types\n4. Deep copying of mutable types to avoid pointer equality issues\n5. Support for PyTorch distributed types like DeviceMesh\n```\n\n```python\nclass ExampleModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.param = nn.Parameter(torch.randn(10))\n        \n    def forward(self, x):\n        # Will trigger EQUALS_MATCH guard for NaN comparison\n        if torch.isnan(x).any():\n            return x * 0\n            \n        # Will trigger EQUALS_MATCH guard for complex number\n        if isinstance(x, complex):\n            return x.real\n            \n        # Will trigger EQUALS_MATCH guard for DeviceMesh\n        if hasattr(x, 'device_mesh'):\n            return x * 2\n            \n        return x + self.param\n",
    "python_code": "\nclass ExampleModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.param = nn.Parameter(torch.randn(10))\n        \n    def forward(self, x):\n        # Will trigger EQUALS_MATCH guard for NaN comparison\n        if torch.isnan(x).any():\n            return x * 0\n            \n        # Will trigger EQUALS_MATCH guard for complex number\n        if isinstance(x, complex):\n            return x.real\n            \n        # Will trigger EQUALS_MATCH guard for DeviceMesh\n        if hasattr(x, 'device_mesh'):\n            return x * 2\n            \n        return x + self.param\n"
}